<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-50</depth>
  <persistent>0</persistent>
  <parentName>parent_dont_pause</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*  Overview: 
Create and place nodes above all upper layer Solid objects */

fieldGenerated=false;
nodeList = 0;
blockSize=32;
grav = 
/**/
1 / 1.5;    /*/
0.5         //*/

fieldWidth=ceil(room_width/blockSize);
fieldHeight=ceil(room_height/blockSize);

for(var i=0;i&lt;fieldWidth;i++){
    for(var j=0;j&lt;fieldHeight;j++){
        //walkable[i,j]=false;
        walkable[i,j]=true;
    }
}

curActor = noone;
//curActor = oEnemy1 
//curActor = oRider

agentHeight = 0;
agentWidth = 0;

dataBinR[0,0] = noone   // runoff databin
dataBinR[1,0] = noone
dataBinJ[0,0] = noone   // jump databin
dataBinJ[1,0] = noone


fallHeight = 0;
motionX = 0;
motionY = 0;
velocityX = 0;
velocityY = 0;


startNode = noone;  // Node starting the path
endNode = noone;    // Node ending the path
curNode = noone;    // Node(s) processed when finding a path
path[0] = 0;        // Node Ids for path: End -&gt; Beginning order
                    // EndNode is in first position and startNode the last
                    
// boolean: Allows Actors to follow the path                    
canFollowPath = 0;
// Precise X value in relation to endNode.x ( +/- value)
tempEndNodeOffset = 0;  // used for avg/small Actors before endNodeOffset
endNodeOffset = 0;      // used for all Actors
// Precise x value destination in a path using endNodeOffset
pathEndX = noone;
// Minumum distance from startNode's origin in order to jump
jumpOffset = 0;




</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Run Simulation
//scr_simulate();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>curActor = oGame.curActor;

// Create nodeList
if (!ds_exists(nodeList, ds_type_list))
    nodeList = ds_list_create();

// Fill nodeList with Nodes above solid blocks
if(!fieldGenerated){
    for(var ii=0;ii&lt;fieldWidth;ii++){
        for(var jj=0;jj&lt;fieldHeight;jj++){
            //walkable[i,j]=false;
            //walkable[i,j]=true;
            var block = instance_position(ii *blockSize, jj *blockSize,oSolid);
            if (instance_exists(block)){
                walkable[ii,jj] = false;
                // create nodes
                if (jj &gt; 0){
                    // if no block is above the current block
                    if (!instance_position(ii *blockSize, (jj-1) *blockSize,oSolid)){
                        // we have a passable tile. create a Node for it
                        node = instance_create(ii *blockSize, (jj-1) *blockSize, oNode);
                        // find clearance
                        node.clearance = scr_getClearanceForTile(node.x, node.y);
                        // nodeList is our global list of all the Nodes that we create
                        ds_list_add(nodeList, node);
                    }
                }
            }
        }
    }  
fieldGenerated=true;
}

       


if (curActor != noone &amp;&amp; !game_is_paused()){
    agentHeight = curActor.height;
    agentWidth = curActor.width;
    sprite_index = curActor.sprite_index;
    image_index = curActor. image_index;
    
    
    with (curActor){
        if (instance_place(x, y+1, oSolid)){
            if (width &gt; oAstar.blockSize &amp;&amp;
             instance_place(x + hspd*global.delta, y, oSolid) &amp;&amp;
             instance_position(x + width/2 * sign(hspd), y + height/2 -1, oNode)){
                oAstar.startNode = instance_position(x + width/2 * sign(hspd), y + height/2 -1, oNode);
            }
            else if (instance_position(x,y + height/2 -1, oNode)){
                oAstar.startNode = instance_position(x,y + height/2 -1, oNode);
            }else{
                oAstar.startNode = instance_place(x, y, oNode);
                // maybe have a collision box that is 16 pixels wide to detect the node
            }
        }
    }
    /*
    with (curActor){
        if (instance_place(x, y+1, oSolid)){
            oAstar.startNode = instance_place(x, y, oNode);
            // maybe have a collision box that is 16 pixels wide to detect the node?
        }  
    }
    */
    
    if (mouse_check_button(mb_left)){
    endNode = instance_position(window_view_mouse_get_x(0),window_view_mouse_get_y(0), oNode);
        if (instance_exists(endNode)){
            endNodeOffset = clamp(window_view_mouse_get_x(0) - endNode.x, -15, 15);
            pathEndX = endNode.x + endNodeOffset;
        }
    }
    
    if (mouse_check_button(mb_right)){
    curActor.x = window_view_mouse_get_x(0);// + window_mouse_get_x() //div blockSize *blockSize;
    curActor.y = window_view_mouse_get_y(0);// + window_mouse_get_y()// div blockSize *blockSize;
    curActor.vspd = 0;
    }
    
    if (endNode == noone){
        path = 0;
    }


    
    // Path Refresh rate
    if (alarm[0] == -1 || alarm[0] == 0)
        alarm[0] = 1/60//global.delta;   // deltaTime is set on the create event
        
    //if alarm[0] == 1
      //  alarm[0] = 0;
        
    if (alarm[0] == 0){
    
        // Simulate Agent Movement and 
        
        for(var r=0; r&lt;ds_list_size(nodeList); r++){
            var node = ds_list_find_value(nodeList, r);
            if (instance_exists(node)){
                 // we can only run off of ledges so check for all ledge Nodes
                if (node.type == NodeType.LedgeLeft || node.type == NodeType.LedgeBoth){
                    scr_checkForStepUpConnections(node, - blockSize);
                    scr_checkForStepDownConnections(node, - blockSize);
                    // ensure we have clearance to walk off the ledge
                     if (walkable[ node.blockSizeX -1, node.blockSizeY ] &amp;&amp; 
                    scr_getClearanceForTile(node.x - blockSize, node.y) &gt;= agentHeight){
                        
                        if (scr_checkForRunoffConnections(node, - blockSize) == 1)
                            scr_checkForJumpConnections(node, - blockSize);
                    }
                }
                if (node.type == NodeType.LedgeRight || node.type == NodeType.LedgeBoth){
                    scr_checkForStepUpConnections(node, blockSize);
                    scr_checkForStepDownConnections(node, blockSize);
                    // ensure we have clearance to walk off the ledge
                     if (walkable[ node.blockSizeX +1, node.blockSizeY ] &amp;&amp; 
                    scr_getClearanceForTile(node.x + blockSize, node.y) &gt;= agentHeight){
                        
                        if (scr_checkForRunoffConnections(node, blockSize) == 1)
                            scr_checkForJumpConnections(node, blockSize);
                        
                    }
                }
            }
        }
        
        //Generate a Path (at set intervals determined by deltaTime variable)
        if (startNode != noone &amp;&amp; endNode != noone){
            curNode = startNode;
            scr_getPath(startNode,endNode);
        }
    }  
    
    // Only when pathEndX, startNode, and endNode are found can the Actor follow the path
    with (curActor){
        if (place_meeting(x,y,oSolid) || oAstar.endNode == noone || oAstar.pathEndX == noone)
            oAstar.canFollowPath = 0;
        else{
            with (oAstar){
                if (pathEndX != noone &amp;&amp; startNode != noone &amp;&amp; endNode != noone)
                    if (scr_getPath(startNode, endNode))
                        canFollowPath = 1;
            }
        }
    }
    
    // Either Actor follows path or remains in same position
    if (canFollowPath)
        scr_followPath();
    else
        curActor.hspd = 0;
    
        
    // if moving left or right and overshoots the endNode, just goto endNode.x
    with (curActor){
        if (oAstar.endNode != noone){
            var c_left = 0;
            var c_right = 0;
            
            if (sign(hspd) == -1){
                c_left = bbox_left + hspd*global.delta;
                c_right = bbox_right + hspd*global.delta;
            }
            else if (sign(hspd) == 1){
                c_right = bbox_right + hspd*global.delta;
                c_left = bbox_left + hspd*global.delta;
            }
        }
    }
}









</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Debugs
if (global.debug){
    // Draw a boundary square for each block, using 0/1 to determine if it is walkable (a solid in it's place)
    /*for(var i=0;i&lt;fieldWidth;i++){
        for(var j=0;j&lt;fieldHeight;j++){
            draw_rectangle(i*blockSize,j*blockSize, (i+1)*blockSize, (j+1)*blockSize, 1);
            draw_text(i*blockSize,j*blockSize, string(walkable[i,j]))
        }
    }*/
    
    // Draw Path - Outside of debug state for now
    for(var z=0;z&lt;array_length_1d(path);z++){
        if (global.debug){
            draw_text(room_width - 200, 144 + (z*16), string(path[z]))
        }    
        if (z != 0)
        draw_line_width_colour(path[z-1].x, path[z-1].y, 
        path[z].x, path[z].y, 10, c_green,c_green) 
    }
    
    with (oActor){
        /* Draw visual bounding box collision 
        w/ consideration to spd and deltaTime */
        draw_set_color(c_red);
        // conditionals for each coordinate
        var c_left = bbox_left;
        var c_right = bbox_right;
        var c_top = bbox_top;
        var c_bot = bbox_bottom;
        
            // Horizontal - - -
        
        // moving right
        if (hspd &gt; 0){
            // collision starts at left of sprite + moves to the right
            c_left = bbox_left;
            c_right = bbox_right + hspd *global.delta;
        }
        //moving left
        else if (hspd &lt; 0){
            // collision starts at right of sprite + moves to the left
            c_left = bbox_left + hspd *global.delta;
            c_right = bbox_right ;
        }
        // hspd is 0
        else{
            c_left = bbox_left;
            c_right = bbox_right;
        }
        
            // Vertical - - -
        
        // moving downwards
        if (vspd &gt; 0){
            // collision starts at top of sprite + moves to down
            c_top = bbox_top;
            c_bot = bbox_bottom + vspd *global.delta;
        }
        //moving upwards
        else if (vspd &lt; 0){
            // collision starts at bottom of sprite + moves to the up
            c_top = bbox_top + vspd *global.delta;
            c_bot = bbox_bottom;
        }
        //vspd is 0
        else{
            c_top = bbox_top;
            c_bot = bbox_bottom;
        }
        // Draw collision Box
        draw_rectangle(c_left ,c_top, c_right , c_bot,true);
        
        /*
        // Draw Actor clearance space ----------------------
        draw_set_color(c_yellow);
        var xR = width/oAstar.blockSize-1;
        var yR = height/oAstar.blockSize-1;
        
        for (var i=-xR; i &lt;= xR; i++){    // -1:left  0:middle    1:right
            for (var j=-yR; j &lt;= yR; j++){
                draw_circle((x+ oAstar.blockSize/2) div oAstar.blockSize*oAstar.blockSize+ (i *oAstar.blockSize), 
                    (y+oAstar.blockSize/2) div oAstar.blockSize*oAstar.blockSize + (j *oAstar.blockSize), 
                    3, 1)
            }
        }
        */
        draw_set_color(c_black);
    }
} 
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
