<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>Parent_LitSurface</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();
/// Initialize 
height = sprite_height;
width  = sprite_width;
image_speed = 0.15;
c = 0;
// movement
spd = 4;
jspd = 12;
hspd = 0; 
vspd = 0;
dir = 1;
//fric = 2 *global.delta;
run_multiplier = 2
airborne = 0;


maxFallHeight = 4; //10;
maxFallSpeed = 10;    

/* PALETTE ***********/

current_pal = 0;
my_pal_sprite = sRider_pal;
if (asset_get_index(sprite_get_name(sprite_index) + "_pal") != -1)
    my_pal_sprite = asset_get_index(sprite_get_name(sprite_index) + "_pal")

//my_pal_sprite = asset_get_index(sprite_get_name(sRider) + "_pal");
//my_pal_sprite = sPalette_test;
///Override stuff.
override_surface=noone;
override_pal_index=1;

/*********************/ 

active = true;  // If Active, able to have a turn
isTurn = 0;     // determines whether its my turn or not
endTurn = 0;    //send signal to oControl that turn is finished


name = "Null";
class = "Null";
level = 5;

// Set Parameters
maxhp_stat = 20;        // max hit points
hp_stat = maxhp_stat;   // current hit points
sp_stat = 2;            // sp_stat = Skill points - used for special skills
wt = 50;                // wt = Wait Time
wt_speed = 10;        // wt_speed = speed - determines turn order
wt_max = 100;
wt_offset = 0;
//t = 0;  //current time
timestamps[10] = 0;


/*  sp is awarded every turn(less) and for doing actions(more)
    spd_stat added to wt after each turn    */

    
// Stats
atk_stat = 5;
def_stat = 5;
int_stat = 5;
res_stat = 5;
dex_stat = 5;
agi_stat = 5;


   
//COMBO ---
combo = 0;
comboMax = 3; // The max of combos that can be performed
canAttack = true;

//The sprites - Frame attacks start. 3 frames after it ends
sprite[0] = 16 // - 19
sprite[1] = 24 // - 27
sprite[2] = 40 // - 43
sprite[3] = 44 // - 47

chain[comboMax] = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>current_pal=wrap(current_pal,0,pal_swap_get_pal_count(my_pal_sprite)-1);

/**/scr_collision();

// Move Horizontally
x += hspd * global.timeMultiplier * global.delta;

// Move Vertically
y += vspd * global.timeMultiplier * global.delta;//maxFallHeight = 5;
//scr_collision();
/*

// Move Horizontally
x = round(x + hspd * global.delta);

// Move Vertically
y = round(y + vspd * global.delta);//maxFallHeight = 5;
*/
/*scr_collision();*/
var rkey = keyboard_check(ord('D'));    //right
var lkey = keyboard_check(ord('A'));    //left
var jkey = keyboard_check_pressed(ord('W'));    //jump
var ckey = keyboard_check(ord('S'));    //crouch
var shift = keyboard_check(vk_space);

 image_blend = -1;
//Check for ground
//if (collision_rectangle(x,y, bbox_right, bbox_bottom+1 ,oSolid, 0, true))
if (place_meeting(x, y+1, oSolid)) 
{
    vspd = 0;
    
    // Crouching -------------------------------
    if (ckey) 
    {
        lkey = false;
        rkey = false;
        /**/
        while (hspd &gt; 0)    //moving right
            hspd = 0;
        while (hspd &lt; 0)
            hspd = 0;
        
        if (hspd == 0)   
            image_blend = c_fuchsia;
        if (jkey)
            ckey = false;   
    }   // End-Crouching -------------------------------
    
    /*
    // Jumping -------------------------------
    if (jkey) {w
        vspd = - jspd;
    }
    */
}else {
    // Gravity
    if (vspd &lt; maxFallSpeed) //10  // higher = heavier
        vspd += oAstar.grav * global.timeMultiplier * global.delta;  
}


if (shift &amp;&amp; jkey)//! airborne) )
        {
           if (place_meeting(x, y+1, oSolid) &amp;&amp; hspd &gt;= spd + (run_multiplier/1.5))
           {
                airborne = 1; 
                
           }
        }
if (airborne)
{
    image_blend = c_purple
    //vspd = -jspd/1.2;
    hspd = hspd + run_multiplier;
    if (lkey)
        hspd -= spd;
    if(rkey)
        hspd += spd;
    if (place_meeting(x, y+1, oSolid) || place_meeting(x+1, y, oSolid) || place_meeting(x-1, y, oSolid))
        airborne =0;
}


if (rkey)
{
    //if (hspd &lt; spd) {
    //    hspd += fric;
    //} else {
        // Fast Run
        if (shift)
        {
            hspd = spd * run_multiplier;
            if (jkey)
                airborne = 1;
        }
        else 
            hspd = spd;
   // }
    dir = 1;

   // Left Wall jump
    if (place_meeting(x-1, y, oSolid) &amp;&amp; !place_meeting(x, y+1, oSolid) &amp;&amp; !lkey)
    {
        image_blend = c_green;
        vspd = 0;
        while (!place_meeting(x + dir * -1, y, oSolid))
            vspd += oAstar.grav/3; 
            vspd =- jspd;
    } 
}

// Moving Left
if (lkey)
{
    //if (hspd &gt; -spd)
    //{
    //    hspd -= fric;
    //} else {
        // Fast Run
        if (shift &amp;&amp; place_meeting(x, y+1, oSolid))
        { 
            hspd = - spd * run_multiplier;
            if (jkey)
            {
                vspd = - jspd // * 1.2;
                //hspd += hspd * 4;
            }
        }
        else 
            hspd = - spd;
    //}
    
    dir = -1;
    
    // Right Wall jump
    if (place_meeting(x+1, y, oSolid) &amp;&amp; !place_meeting(x, y+1, oSolid) &amp;&amp; !rkey)
        {
            vspd += oAstar.grav/2.5; 
            vspd =- jspd;
        }   
}

// Check for not moving
if ( (!rkey &amp;&amp; !lkey) || (rkey &amp;&amp; lkey) ) 
{  
            //hspd = 0;    
}


// Turn Order 

if(!isTurn){
        hspd = 0;
        vspd = 0;
    }

if (active){ //your turn
    


}
else{ //not you turn
    hspd = 0;
    

}






// Combo Antics --------------------------------------------
if (keyboard_check_pressed(vk_control) &amp;&amp; canAttack){
    canAttack = false
    // The sprite will change depending on the combos;
    image_index = sprite[combo]
    
    
        //image_index = sprite[combo] + 3;
    
    
    
    combo = (combo+1)%comboMax;
    //Increment the combo and not let it exceed the comboMax
    
    alarm[0] = 25; // time until able to continue combo anim
    alarm[1] = 75; // time until reset combo
    //alarm[2] = 15; // time unitl able to input attack
    
    // as soon as chain[...] is filled, do the action
}

// Change the sprite to the idle animation :
if(canAttack){
    if (image_index &lt; 0)
        image_index = 0;
    if (image_index &gt;= 4)
        image_index = 0;
}
else{
clamp(image_index,sprite[combo], sprite[combo] + 3);
if (image_index &lt;= sprite[combo])
    image_index = sprite[combo];
if (image_index &gt; sprite[combo] + 3)
    image_speed = 0;
}

/*/*/
while (place_meeting(x,y, oSolid)){
    y -=1;
}
//*/

/*
if (position_meeting(x, y+sprite_height/2, oSolid)) 
{
    y -=1;
}
if (position_meeting(x, y-sprite_height/2, oSolid)) 
{
    y +=1;
}
if (position_meeting(x-sprite_width/2, y, oSolid)) 
{
    x +=1;
}
if (position_meeting(x+sprite_width/2, y, oSolid)) 
{
    x -=1;
}
*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>


draw_text(x,y-32, string(wt));
/**/
for(var t=0; t&lt;array_length_1d(timestamps)-1;t++)
    draw_text(x ,y-80-(16 * t), string(timestamps[t]));


///Draw With Unlimited Palette Swap    
if (my_pal_sprite){ 
    pal_swap_set(my_pal_sprite,current_pal,false);
        event_inherited();
        draw_self();
    pal_swap_reset();
}
else{
    event_inherited();
    draw_self();
}




</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
