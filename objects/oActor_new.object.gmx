<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Initialize 
event_inherited()   //step counter inheritance/ built in alarms

/* PALETTE ***********/

current_pal = 0;
my_pal_sprite = sPalette_test;
///Override stuff.
override_surface=noone;
override_pal_index=1;

/*********************/ 

active = true;  // If Active, able to have a turn
isTurn = 0;     // determines whether its my turn or not
endTurn = 0;    //send signal to oControl that turn is finished

image_speed = 0.15;

// Set event state to Control's event state (if it exists)
if (instance_exists(oControl))
    event = oControl.event;
else
    event = -1;

name = "Error";
class = "Error";
level = 5;

// Set Parameters
maxhp_stat = 20;        // max hit points
hp_stat = maxhp_stat;   // current hit points
sp_stat = 2;            // sp_stat = Skill points - used for special skills
wt = 50;                // wt = Wait Time
wt_speed = 10;        // wt_speed = speed - determines turn order
wt_max = 100;
t = 0;  //current time
timestamps[10] = 0;

/*  sp is awarded every turn(less) and for doing actions(more)
    spd_stat added to wt after each turn    */

    
// Stats
atk_stat = 5;
def_stat = 5;
int_stat = 5;
res_stat = 5;
dex_stat = 5;
agi_stat = 5;

// movement
grav = 1;
spd = 4;
jspd = 12;
hspd = 0; 
vspd = 0;
dir = 1;
fric = 2;
run_multiplier = 2
airborne = 0;


    
    
//COMBO ---
combo = 0;
comboMax = 3; // The max of combos that can be performed
canAttack = true;

//The sprites - Frame attacks start. 3 frames after it ends
sprite[0] = 16 // - 19
sprite[1] = 24 // - 27
sprite[2] = 40 // - 43
sprite[3] = 44 // - 47

chain[comboMax] = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Time unitl able to input attack
if(!canAttack){
    if (keyboard_check_pressed(vk_control)){
    
    }
    
    // Other attacks - Light/ Heavy, etc
    else if (keyboard_check_pressed(ord("R"))){
   
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Time until reset combo
combo = 0;
image_speed = 0.2
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Time until able to continue combo anim
canAttack = true;
image_speed = 0.2
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// State Machines
current_pal=wrap(current_pal,0,pal_swap_get_pal_count(my_pal_sprite)-1);

// event variable is controlled by oControl
event = oControl.event;

switch(event)
{
    case Event.overworld:
        scr_player_overworld();
        break;
    
    case Event.encounter:
        scr_player_encounter();
        break;
        
    case Event.battle:
        scr_player_battle();
        break;

    case Event.endBattle:
        scr_player_endBattle();
        break;
}
/*
switch(state){
    case State.idle:
        scr_idle();
        break;
        
    case State.idle:
        scr_idle();
        break;
}

if (

// Platform physics
*/
if (event = Event.battle &amp;&amp; isTurn || event = Event.overworld){

    var rkey = keyboard_check(ord('D'));    //right
    var lkey = keyboard_check(ord('A'));    //left
    var jkey = keyboard_check_pressed(ord('W'));    //jump
    var ckey = keyboard_check(ord('S'));    //crouch
    //var rjkey = keyboard_check_released(ord('W'));   // run jump / launch
    var shift = keyboard_check(vk_space);
    
    var temp_grav = grav;
    //ssssfric = 2;
     image_blend = -1;
    //Check for ground
    if (place_meeting(x, y+1, oSolid)) 
    {
        vspd = 0;
        
        // Crouching -------------------------------
        if (ckey) 
        {
            lkey = false;
            rkey = false;
            
            while (hspd &gt; 0)    //moving right
                hspd -= fric;
            while (hspd &lt; 0)
                hspd +=fric;
            
            if (hspd == 0)   
                image_blend = c_fuchsia;
            if (jkey)
                ckey = false;   
        }   // End-Crouching -------------------------------
        
        
        // Jumping -------------------------------
        if (jkey) {
            vspd = - jspd// + hspd * dir;
            hspd = hspd;
            //hspd = hspd * dir
           
               // do { hspd = hspd * 5 } 
                //    until ( place_meeting(x, y+1, oSolid) )
            
        }
    } 
    else {
        // Gravity
        if (vspd &lt; 10)  // higher = heavier
        {
            temp_grav = grav/1.5;
            vspd += temp_grav;
        
            /*if (airborne)
            {
                temp_grav = grav/30;
                vspd += temp_grav;
            }
            */
        }
        //if (keyboard_check_released(ord('W')) &amp;&amp; vspd &lt; -4) {
            //vspd = -4;
       // }
        
       /* if (place_meeting(x + dir, y , oSolid) &amp;&amp;  == 0 &amp;&amp; vspd &gt;= 0)
        {
            if (halt == 1)
            {
                vspd = 0;
                dir *= -1;
                halt = 0;
            }
            //while (!place_meeting(x + dir * -1, y, oSolid))
                vspd += grav/2.5;
            
            if (jkey) {
                vspd =- jspd;
                
    }
        }    
        else if (vspd &lt; 35)  // higher = heavier
        {
            vspd += grav;
        }*/
        
    }
    
    if (shift &amp;&amp; jkey)//! airborne) )
            {
               if (place_meeting(x, y+1, oSolid) &amp;&amp; hspd &gt;= spd + (run_multiplier/1.5))
               {
                    airborne = 1; 
                    
               }
            }
    if (airborne)
    {
        image_blend = c_purple
        //vspd = -jspd/1.2;
        hspd = hspd + run_multiplier;
        if (lkey)
            hspd -= spd;
        if(rkey)
            hspd += spd;
        if (place_meeting(x, y+1, oSolid) || place_meeting(x+1, y, oSolid) || place_meeting(x-1, y, oSolid))
            airborne =0;
    }
    
    
    if (rkey)
    {
        if (hspd &lt; spd) {
            hspd += fric;
        } else {
            // Fast Run
            if (shift)
            {
                hspd = spd * run_multiplier;
                if (jkey)
                    airborne = 1;
            }
            else 
                hspd = spd;
        }
        dir = 1;
    
       // Left Wall jump
        if (place_meeting(x-1, y, oSolid) &amp;&amp; !place_meeting(x, y+1, oSolid) &amp;&amp; !lkey)
        {
            image_blend = c_green;
            vspd = 0;
            while (!place_meeting(x + dir * -1, y, oSolid))
                vspd += grav/3; 
                vspd =- jspd;
        }   
        /*
         Left Wall jump
        if (place_meeting(x-1, y, oSolid) &amp;&amp; !place_meeting(x, y+1, oSolid))
        {
            image_blend = c_yellow;
            vspd = 0;
            if (jkey)
                vspd += grav/2.5; 
                vspd =- jspd;
        }  
        */
    }
    
    // Moving Left
    if (lkey)
    {
        
        if (hspd &gt; -spd)
        {
            hspd -= fric;
        } else {
            // Fast Run
            if (shift &amp;&amp; place_meeting(x, y+1, oSolid))
            { 
                hspd = - spd * run_multiplier;
                if (jkey)
                {
                    vspd = - jspd * 1.2;
                    //hspd += hspd * 4;
                }
            }
            else 
                hspd = - spd;
        }
        
        dir = -1;
        
        // Right Wall jump
        if (place_meeting(x+1, y, oSolid) &amp;&amp; !place_meeting(x, y+1, oSolid) &amp;&amp; !rkey)
            {
                vspd += grav/2.5; 
                vspd =- jspd;
            }   
    }
    
    // Check for not moving
    if ( (!rkey &amp;&amp; !lkey) || (rkey &amp;&amp; lkey) ) 
    {
        if (hspd != 0) {
            if (hspd &lt; 0) {
                hspd += fric;
            } else {
                hspd -= fric;
            }
        }
    }

}

scr_collision();

// Move Horizontally
x += hspd;

// Move Vertically
y += vspd;


// Combo Antics --------------------------------------------
if (keyboard_check_pressed(vk_control) &amp;&amp; canAttack){
    canAttack = false
    // The sprite will change depending on the combos;
    image_index = sprite[combo]
    
    
        //image_index = sprite[combo] + 3;
    
    
    
    combo = (combo+1)%comboMax;
    //Increment the combo and not let it exceed the comboMax
    
    alarm[0] = 25; // time until able to continue combo anim
    alarm[1] = 75; // time until reset combo
    //alarm[2] = 15; // time unitl able to input attack
    
    // as soon as chain[...] is filled, do the action
}

// Change the sprite to the idle animation :
if(canAttack){
    if (image_index &lt; 0)
        image_index = 0;
    if (image_index &gt;= 4)
        image_index = 0;
}
else{
clamp(image_index,sprite[combo], sprite[combo] + 3);
if (image_index &lt;= sprite[combo])
    image_index = sprite[combo];
if (image_index &gt; sprite[combo] + 3)
    image_speed = 0;
}




























</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_text(x,y-32, string(wt));
/**/
for(var t=0; t&lt;array_length_1d(timestamps)-1;t++)
    draw_text(x ,y-80-(16 * t), string(timestamps[t]));


///Draw With Unlimited Palette Swap     
pal_swap_set(my_pal_sprite,current_pal,false);
    draw_self();
pal_swap_reset();

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
